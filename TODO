
* AC matching

* Match BlankSequence and BlankNullSequence

* Implement level specification

* Implement autoload. e.g. for code written in SJulia

* Fix chained comparison. Remove true comparison. Return conjunction.

* We can't disable infseval because it does some computation.

* Translation to and from SymPy is slow. For `Integrate' this is
usually not a problem. But, manipulation (eg Expand) of large expressions
may be hundreds of times faster in SymPy than the translation of the
result.

* [m, n] = [n, Mod(m, n)] Destructuring assignment

* gensyms that escape from Module can't be entered (parsed) at command line because of comment
 chars. Mma gensyms can be entered.  We need LModule only to remove temporary symbols. But,
 returned gensym symbols are entered again into the symbol table, with no special attributes.
  Mma gives gensyms attribute 'Temporary' and removes them when they go out of scope.
  We should use a separate gensym counter for SJulia, eg. $ModuleNumber.

* For 'Contexts', (like Julia modules), we should use ::, because the parser deals with it. Or '.',
  which is waht Julia uses for modules.  Back tick will not work.

* Give exact values for CosD

* need a system for including packages and the associated sjulia capability only
 if the module is installed (or available)

* 'Do' with invalid iterator raises error. It shold warn and return unevaluated form.

* Allow user to set max number of mevals.

* Allow user to set the output capture length   
   
* Module should convert single line to compound expression.

* Getting error message "PyObject call" instead of unevaluated
 expression for, eg Integrate(x + c). Probably has to do
 with changing the REPL parsing code.

* Can't throw or handle exceptions correctly when translating AST.
   Find out why.
   
* Error messages have become shorter and more cryptic. Why
  e.g MethodError(SJulia._do_Comparison,(ex,==,((-1 + x) ^ 2) * (1 + 2 * x + 2 * (x ^ 2) + x ^ 3)))
  when comparing unbound symbol to polynomial

* Example message ErrorException("Symbol 'Part' is protected.").

* Warning message still appears for [a => b, ...]

* Map should map over values in a Dict.

* Map should map over multiple argument lists. Now it accepts only
  one argument list.
  "Map can be used in an operator form. For example Map(f)(expr)."
   This is wrong or incorrectly documented.

* Map needs to take level argument, and Heads -> True   

* Derivative. Expressions with expressions as the head. How will this ?
   
###############################################################################

 ===  DONE ===

* @doap fails with annotated arguments. The type parameters need to be
   quoted ors something.a   
   
* Make Void (nothing, I think) meval to Null (better yet, avoid Void; explicitly return Null)
   
* Sympy  I * Infinity <--> DirectedInfinity[I]
   
*  Bug:
   ex = Exp(-t)*t^(a-1)
   Out(1) = E ^ (-t) * (t ^ (-1 + a))
   sjulia 2> Integrate(ex,t, conds => "none")
   WARNING: Gamma::argr: Gamma called with two arguments; one argument is expected.
   Out(2) = Integrate(ex,t,conds => "none")
   
* Use this test, or example. h([x_,y_]) := x^y

*  The result here should be simplified
   zz(aa(x_)) ^= x^2
   sjulia > zz(aa(3))
   3 ^ 2

*  Fixed. at least we get one level of subexpressions by calling mergeargs in sympy.jl
   Cos(Pi/6) returns unevaluated. Fix this, or use Sympy instead
   But, enabling the sympy version causes the dirty symbol test in
   evaluation_test.jl to fail. Sin will fail dirty symbol test because
   it is done by SymPy.

* When sum is unbound , we get this:
sjulia > Do( sum += i, [i,[1,2,3,4,5]])
1 + sum
ERROR: Too many meval entries 201
 in eval(::Module, ::Any) at ./boot.jl:237
Mma gives this:
AddTo::rvalue: sum is not a variable with a value, so its value cannot be
     changed.

* If needs third branch

* Allow multiline input at sjulia prompt (or from file ??) julia mode already
 does allow this. Check if parsed string returns Expr with head :incomplete


* Print sympy doc if no sjulia doc is available. Maybe even
  strip out the 'from sympyt import' part

* Integrate( Exp(-t)*t^(a-1),[t,0,Infinity])  fails because it returns an expression with type Base.#<,
  no idea what this object is. We should convert it to SJulia comparison, of course.
  For the moment we print an error.

  Fixed, but resdesign should be considered
* Reducing Times[]. When we get Infinity, we need to check for the numeric
  coefficient, so we can return DirectedInfinity[-1].
  How to do this efficiently ? We should probably compute the numeric part
  of the product as we do the analysis and then write a new array with only
  the non-numeric parts and work from there.  So, the entire procedure of
  removing numbers in sweeps will be replaced.

* Not true, or no longer: *** Yes, this works, but only on a list,
  which is how Count works. But, we could do it on args of any function.
  For instance cop = Count(_^2) defines a function that counts
  the number of arguments that have the form of a square.
  This does work: MatchQ( b^2, _^2)
